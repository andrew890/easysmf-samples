## Sample 5: Accessing Sections in Lists

[Sample 5 Source Code: sample5.java](./src/sample5.java)

When a SMF record may have multiple instances of a section, the sections will be returned in a `List<T>`.
Sometimes a record will have no instances of a particular section - in that case an empty list is returned. 

Sample 5 generates a report based on the SMF type 30 EXCP Section.

The report lists job steps with a STEPLIB entry in the EXCP sections.
The program ignores jobs where the job name begins with the userid.
Each combination of Jobname, Step Number, Step Name and Program Name is listed only once.

(This sample is used to demonstrate various techniques.
It is not intended to imply that there is any problem with jobs using a STEPLIB.)

#### Eliminating Duplicates

To eliminate duplicates, we collect the entries in a `Set<T>`. 
A Set is a collection which does not allow duplicate entries. 
We need to create a class to contain the job/step/program information, 
and provide `hashCode()` and `equals(Object)` methods which the Set will use to test for equality.

This is an example of creating a class that can be used as a Key in a HashMap.
You use this technique to summarize based on more complex keys than the simple String used in
[Sample 4](./Sample4.md).

```
private static class JobStepProgram
{	        
    private String jobname;
    private int stepnumber;
    private String stepname;
    private String programname;      
...
    @Override
    public int hashCode() {
        return Objects.hash(jobname, programname, stepname, stepnumber);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        JobStepProgram other = (JobStepProgram) obj;
        return Objects.equals(jobname, other.jobname)
            && Objects.equals(programname, other.programname) 
            && Objects.equals(stepname, other.stepname)
            && stepnumber == other.stepnumber;
    }
...
}
```     

##### A short discussion on hashcode() and equals(Object) #####

The `equals(Object obj)` method needs to compare all the properties of the object (jobname, step number, step name and program name) that determine whether the objects are equal.

The most important rule for `hashcode()` is that objects that are equal must return the same hash code. Otherwise collections like HashSet and HashMap will not work correctly. This means that if you provide an equals() method, you **must** also provide a hashcode() method.

The second rule is that objects that are **not** equal **should** return different hash codes. It is not absolutely required (and not even possible for every instance of every object) but if hash collisions are frequent it can badly affect performance of the hash based collections.

The methods shown were generated by Eclipse. Equals compares the fields in the class. The Objects.hash(...) method combines hashes from the same fields into a new hash using a method that should be resistant to collisions.

This is a bare bones discussion of hashcode() and equals(), there is plenty of Java books and documentation that goes into greater depth.